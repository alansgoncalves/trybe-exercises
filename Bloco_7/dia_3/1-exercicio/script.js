// // Acompanhe um exemplo do uso do mÃ³dulo assert abaixo. Rode as expressÃµes separadamente, comentando a linha que nÃ£o serÃ¡ executada para ver o resultado.

// const assert = require('assert'); // Sintaxe para incluir o mÃ³dulo assert

// assert.strictEqual(50, 50); // Sem erros: 50 == 50
// assert.strictEqual(50, 70); // AssertionError: 50 == 70



// // Neste outro exemplo utilizamos o assert para testar o retorno esperado da funÃ§Ã£o division :

// const assert = require('assert');

// function division(x, y) {
//   return x / y;
// }

// const expected = division(10, 2);

// assert.strictEqual(expected, 5, 'Nove dividido por trÃªs Ã© igual a trÃªs');



// // Podemos combinar vÃ¡rios mÃ©todos do assert quando escrevemos nossos testes. Isso pode ser muito Ãºtil para ampliar a cobertura do teste em casos de falhas! Observe:

// const assert = require('assert');

// function add(a, b) {
//   return a + b;
// }

// const expected = add(1, 2);

// assert.ok(expected === 32, 'Um mais dois Ã© igual a trÃªs'); // Checa se o primeiro argumento Ã© verdadeiro

// assert.strictEqual(expected, 3, 'Um mais dois Ã© igual a trÃªs'); // Checa se o primeiro e segundo argumentos sÃ£o iguais em valor e tipo (===)

// assert.notStrictEqual(expected, 4, 'Um mais dois Ã© igual a trÃªs (e nÃ£o quatro!)'); // Checa se o primeiro e segundo argumentos sÃ£o diferentes (!==)



// // Ã‰ possÃ­vel tambÃ©m testar estruturas como arrays e objetos:

// const assert = require('assert');

// const list1 = [1, 2, 3, 4, 5];
// const list2 = [1, 2, 3, 4, 5];

// assert.deepStrictEqual(list1, list2, 'Erro: list1 e list2 nÃ£o sÃ£o estritamente iguais');



// const person1 = { name: 'john', age: 21 };
// const person2 = { name: 'john', age: 21 };

// assert.deepStrictEqual(person1, person2, 'Erro: person1 e person2 nÃ£o sÃ£o estritamente iguais');



// const person3 = { name: 'john', age: 19 };

// assert.notDeepStrictEqual(person1, person3, 'Erro: os valores dos objetos sÃ£o estritamente iguais');



// Testes unitÃ¡rios e a melhoria no cÃ³digo

function division(x, y) {
  return x / y;
}

const assert = require('assert');

assert.strictEqual(division(10, 2), 5); // OK
assert.strictEqual(division(10, 0), 0); // ðŸ’£ ERRO no segundo strictEqual, nÃ£o Ã© possÃ­vel realizar divisÃ£o por 0

// Podemos fazer isso usando a palavra chave throw , que no javascript serve para lanÃ§ar um erro. Usaremos ele, entÃ£o, para lanÃ§ar um erro caso o divisor y seja igual a zero:

const assert = require('assert');

function division(x, y) {
  if (y === 0) throw new Error('parameter y must not be 0');
  return x / y;
}

assert.strictEqual(division(10, 2), 5); // OK
assert.throws(() => { division(10, 0); }, /^Error: parameter y must not be 0$/); // OK




// Sobre o throw

// Ao executar os cÃ³digos escritos por vocÃª, nÃ£o hÃ¡ dÃºvidas de que vocÃª jÃ¡ se deparou com mensagens de erro quando algo nÃ£o estava fazendo o que deveria. Seja um erro de sintaxe ou uma variÃ¡vel indefinida em algum lugar, lidar com erros Ã© uma tarefa comum na vida de qualquer pessoa desenvolvedora.

const assert = require('assert');
function division(x, y) {
  // Queremos que o cÃ³digo retorne um erro com uma mensagem especÃ­fica
  // caso o parÃ¢metro y seja 0. Por isso lanÃ§amos uma exceÃ§Ã£o se essa condiÃ§Ã£o
  // for verdadeira, o que irÃ¡ interromper a execuÃ§Ã£o da funÃ§Ã£o.

  if (y === 0) throw new Error('parameter y must not be 0');
  return x / y;
}
assert.strictEqual(division(10, 3), 5);
assert.throws(() => { division(10, 0); }, /^Error: parameter y must not be 0$/);